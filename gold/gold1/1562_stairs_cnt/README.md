처음에 문제를 다 읽고 DP문제라고 판단 
그래서 10개 9876543210 여거에서 11 12 13 이렇게 확장해 나가려고 했지만 
따로 규칙성이 안보였음 
그래서 너무 안보여서 GPT한테 물어보니 DP와 비트 마스크라는 것을 같이 사용해서 풀어야한다고 설명 
그래서 비트 마스크를 공부하고 3차원 dp를 만들어서 풀었음 

비트 마스크 블로그 정리한 것을 복붙

정의 : 여러 개의 1과 0을 하나의 정수의 비트 단위로 표현하는 기법 

​

0b0000000~~ 이런 식으로 표기 

​

- 핵심 연산

 (1) 1 << X   :  X번째 비트만 1로 만든다 , 1을 x만큼 왼쪽으로 shift

예시 : 1 << 3 의 결과는 1을 3번 왼쪽으로 shift한 0b1000

​

(2)  mask | (1<<X) . OR 연산

mask의 x번째 비트를 추가  

​

(3) mask & (1 << X) , AND 연산 

mask의 x번째 비트가 있는지 확인 

​

(4) mask & ~(1<<X) , AND + NOT 연산 

mask의 X번째 비트를 끈다 (제거)

​

(5) mask ^ (1 << X) XOR 연산 

mask의 X번쨰 비트를 반전 (toggle)

​

(6) FULL_MASK  = ( 1 << 10)  -1 

0~9까지의 숫자를 썼는지 확인하기 위해 비트마스크를 이용할 때 

1을 왼쪽으로 10칸 이동 : 0b10000000000

-1을 뻄 : 0b111111111 -> 0~9번째 비트가 모두 1이 된다 

여기에 FULL_MASK & mask 이렇게 하면 모든 비트가 있는 가를 확인할 수 있다. 

​

-언제 쓰는가? 

부분집합 표현  : N개의 요소 중 어떤 걸 포함할지 표현 (for mask in range(i<<n))

방문 상태 기록 : 그래프 , 외판원 순회 (TSP), DP 상태 추적

 상태를 비트로 줄여서 공간 절약

 플래그 관리 : 옵션,조건,상태 표시 (게임 시스템 등) 

​

-장점 

빠름 (O(1) 연산) , 메모리를 효율적으로 사용 가능 , DP 상태 압축에 강함

-단점 

요소 수가 많아지면 비트의 폭이 증가한다. ,직관성이 낮고 디버깅에 어려움이 있음 , 30~40비트 이상은 현실적으로 힘들다

​
